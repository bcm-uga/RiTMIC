---
title: "RiTMIC: RegulatIon of Tumor MIcroenvironment Composition"
subtitle: "Part 4 : Deconvolution by calling EDec functions"
author: "Magali Richard, Clementine Decamps, Florent Chuffart, Fabien Quinquis, Daniel Jost"
contact: 
date: "`r Sys.Date()`"
output: 
  rmarkdown::html_document:
    toc: true
    toc_float: true
    toc_depth: 3
    number_sections: true
vignette: >
  %\VignetteIndexEntry{statistics}
  %\VignetteEngine{knitr::rmarkdown}
  %\usepackage[utf8]{inputenc}
---

```{r echo=FALSE, eval=TRUE}
knitr::opts_chunk$set(collapse=TRUE, comment = "#>", fig.width=9, fig.height=6, eval=TRUE, echo=TRUE, results="verbatim", dpi=75)
layout(1, respect=TRUE)
```


# Introduction

`RiTMIC` (**R**egulat**I**on of **T**umor **MI**croenvironment **C**omposition) is an open-access R package that simulates the necessary tools to perform `PenDA` analysis, perform analysis with `PenDA` and apply visualization tools to the `PenDA` output. 

`RiTMIC` Part 4: **Deconvolution by calling EDec functions**

```{r label = "header", echo = FALSE, eval = TRUE}
library(shiny)
library(shinythemes)
library(pheatmap)
library(plotly)
library(cowplot)
library(ggplot2)
library(fgsea)
library(matrixStats)
library(medepir)
```

```{r, label="Partie 1: Importation, Vérification et filtration des jeux de données "}
# Données de références poumon gtex
gtex <- readRDS("/home/quinquif/Datas/projects/data/import_data/RiTMIC/study_gtex.rds")
gtex_bronch_lungs <-c()
idx <- rownames(gtex$exp_grp[gtex$exp_grp$tissue_group_level1 == "bronchus_lung", ])
gtex_bronch_lungs$data <- gtex$data[, idx]
gtex_bronch_lungs$exp_grp <- subset(gtex$exp_grp,rownames(gtex$exp_grp) %in% colnames(gtex_bronch_lungs$data))
dim(gtex_bronch_lungs$data)
dim(gtex_bronch_lungs$exp_grp)
# Vérification de la position des identifiants de la cohorte entre la matrice D et la matrice de paramètres 
table(rownames(gtex_bronch_lungs$exp_grp) == colnames(gtex_bronch_lungs$data))

LUNGBRB_trs <- readRDS("/home/quinquif/Datas/projects/data/import_data/RiTMIC/study_LUNGBRB_trscr_gs.rds")
#Important : Utiliser uniquement les variables data (jeu de donnée) et exp_group (pour les parametres ages, sexe blabla... ) 
table(LUNGBRB_trs$exp_grp[, "histology_type.y"])
dim(LUNGBRB_trs$exp_grp)
table_wo_na <- complete.cases(LUNGBRB_trs$exp_grp[, "histology_type.y"])
LUNGBRB_trs$exp_grp <- LUNGBRB_trs$exp_grp[table_wo_na,]
dim(LUNGBRB_trs$exp_grp)

# Filtration du groupe adk 
LUNGBRB_trs_adk <- c()
LUNGBRB_trs_adk$exp_grp <- LUNGBRB_trs$exp_grp[LUNGBRB_trs$exp_grp[, "histology_type.y"] == "Adenocarcinoma", ]
dim(LUNGBRB_trs_adk$exp_grp)
table(LUNGBRB_trs_adk$exp_grp$histology_type.y)
filter = colnames(LUNGBRB_trs$data) %in% rownames(LUNGBRB_trs_adk$exp_grp)
LUNGBRB_trs_adk$data <- LUNGBRB_trs$data[, filter]
# Vérification de la filtration 
dim(LUNGBRB_trs_adk$data)
dim(LUNGBRB_trs_adk$exp_grp)

# Filtration du groupe sqc 
LUNGBRB_trs_sqc <- c()
LUNGBRB_trs_sqc$exp_grp <- LUNGBRB_trs$exp_grp[LUNGBRB_trs$exp_grp$histology_type.y == "Squamous cell carcinoma", ]
dim(LUNGBRB_trs_sqc$exp_grp)
filter = colnames(LUNGBRB_trs$data) %in% rownames(LUNGBRB_trs_sqc$exp_grp)
LUNGBRB_trs_sqc$data <- LUNGBRB_trs$data[, filter]
# Vérification de la position des identifiants de la cohorte entre la matrice D et la matrice de paramètres 
table(rownames(LUNGBRB_trs_sqc$exp_grp) == colnames(LUNGBRB_trs_sqc$data))

LUNGBRB_met <- readRDS("/home/quinquif/Datas/projects/data/import_data/RiTMIC/study_epilung_meth2.rds")
names(LUNGBRB_met)

LUNGBRB_met_adk <- c()
filter = colnames(LUNGBRB_met$data) %in% colnames(LUNGBRB_trs_adk$data)
LUNGBRB_met_adk$data <- LUNGBRB_met$data[, filter]
# Vérification de la filtration 
dim(LUNGBRB_met_adk$data) # 72 individus
dim(LUNGBRB_trs_adk$data) # 85 individus
# Filtration du groupe sqc 
LUNGBRB_met_sqc <- c()
filter = colnames(LUNGBRB_met$data) %in% colnames(LUNGBRB_trs_sqc$data)
LUNGBRB_met_sqc$data <- LUNGBRB_met$data[, filter]
dim(LUNGBRB_met_sqc$data) # 50 individus
dim(LUNGBRB_trs_sqc$data) # 60 individus

TCGA_LUAD_trs <- readRDS("/home/quinquif/Datas/projects/data/import_data/RiTMIC/study_TCGA-LUAD_trscr.rds")
names(TCGA_LUAD_trs)
dim(TCGA_LUAD_trs$data)
dim(TCGA_LUAD_trs$exp_grp)
# Vérification de la position des identifiants de la cohorte entre la matrice D et la matrice de paramètres 
table(rownames(TCGA_LUAD_trs$exp_grp) == colnames(TCGA_LUAD_trs$data))
# Important : Même chose que pour LUNGBRB_trs, n'utiliser que les variables data et exp_group pour former les matrices 

TCGA_LUAD_meth <- readRDS("/home/quinquif/Datas/projects/data/import_data/RiTMIC/study_TCGA-LUAD_meth.rds")

names(TCGA_LUAD_meth)
dim(TCGA_LUAD_meth$data) # 636 individus
dim(TCGA_LUAD_trs$data) # 574 individus 

filter = colnames(TCGA_LUAD_meth$data) %in% colnames(TCGA_LUAD_trs$data)# Filtration du groupe LUAD met 
TCGA_LUAD_meth$data <- TCGA_LUAD_meth$data[, filter]
dim(TCGA_LUAD_meth$data) # 534 individus
filter = colnames(TCGA_LUAD_trs$data) %in% colnames(TCGA_LUAD_meth$data)
TCGA_LUAD_trs$data <- TCGA_LUAD_trs$data[, filter]
dim(TCGA_LUAD_trs$data)
TCGA_LUAD_trs$exp_grp <- TCGA_LUAD_trs$exp_grp[filter, ]
dim(TCGA_LUAD_trs$exp_grp)

# Reorder column by column names to pass tests 
TCGA_LUAD_trs$data <- TCGA_LUAD_trs$data[, order(colnames(TCGA_LUAD_trs$data))]
TCGA_LUAD_meth$data <- na.omit(TCGA_LUAD_meth$data[, order(colnames(TCGA_LUAD_meth$data))])
TCGA_LUAD_trs$exp_grp  <- TCGA_LUAD_trs$exp_grp[order(rownames(TCGA_LUAD_trs$exp_grp)), ]
table(colnames(TCGA_LUAD_trs$data) == colnames(TCGA_LUAD_meth$data))
table(colnames(TCGA_LUAD_trs$data) == rownames(TCGA_LUAD_trs$exp_grp))


TCGA_LUSC_trs <- readRDS("/home/quinquif/Datas/projects/data/import_data/RiTMIC/study_TCGA-LUSC_trscr.rds")
names(TCGA_LUSC_trs)
# Important : N'utiliser que les variables data et exp_group pour former les matrices D
dim(TCGA_LUSC_trs$data)
dim(TCGA_LUSC_trs$exp_grp)
# Vérification de la position des identifiants de la cohorte entre la matrice D et la matrice de paramètres 
table(rownames(TCGA_LUSC_trs$exp_grp) == colnames(TCGA_LUSC_trs$data))


TCGA_LUSC_meth <- readRDS("/home/quinquif/Datas/projects/data/import_data/RiTMIC/study_TCGA-LUSC_meth.rds")
names(TCGA_LUSC_meth)
dim(TCGA_LUSC_meth$data) # 572 individus
dim(TCGA_LUSC_trs$data) # 550 individus 
# Filtration du groupe LUSC met 
filter = colnames(TCGA_LUSC_meth$data) %in% colnames(TCGA_LUSC_trs$data)
TCGA_LUSC_meth$data <- na.omit(TCGA_LUSC_meth$data[, filter])
dim(TCGA_LUSC_meth$data) # 507 individus
filter = colnames(TCGA_LUSC_trs$data) %in% colnames(TCGA_LUSC_meth$data)
TCGA_LUSC_trs$data <- TCGA_LUSC_trs$data[, filter]
dim(TCGA_LUSC_trs$data)
TCGA_LUSC_trs$exp_grp <- TCGA_LUSC_trs$exp_grp[filter, ]
dim(TCGA_LUSC_trs$exp_grp)
```

```{r, label = "Partie 2: Création de la matrice T et A à partir de matrice D puis création de la surrogate matrix D"}
# Rentrer la matrice de methylation pour EDec_step_1 donc besoin d'implémenter les matrices met 
table(colnames(TCGA_LUAD_meth$data) == rownames(TCGA_LUAD_trs$exp_grp))
# Filtration du exp_grp 
TCGA_LUAD_trs$exp_grp <- TCGA_LUAD_trs$exp_grp %>% select(id_sample, sample_source, sex, age_min,age_max,id_morphology,t,n,tnm_stage,dfs_months,os_months, relapsed,exposure)
LUAD_CF <- medepir::CF_detection(TCGA_LUAD_meth$data,TCGA_LUAD_trs$exp_grp,threshold = 0.15, ncores=2)
table(rownames(TCGA_LUAD_trs$exp_grp) == colnames(LUAD_CF))
# Passage de 21785 à 11663 sondes 
saveRDS(LUAD_CF,"~/Datas/projects/data/import_data/RiTMIC/TCGA_LUAD_CF.rds")
LUAD_CF <- readRDS("~/Datas/projects/data/import_data/RiTMIC/TCGA_LUAD_CF.rds")
dim(LUAD_CF)

while (!is.null(dev.list()))  dev.off()
pdf("LUAD_plot_k.pdf")
medepir::plot_k(LUAD_CF)
dev.off()

# PC = 6, donc d'après la loi de Cattel, K = 7+1 = 8
# Selection des paramètres/sondes
D_FS = medepir::feature_selection(LUAD_CF)
# Lancement de la déconvolution avec EDec stage 1 
deconv = EDec::run_edec_stage_1(meth_bulk_samples = LUAD_CF, informative_loci = rownames(D_FS), num_cell_types = 8)
saveRDS(deconv,"~/Datas/projects/data/import_data/RiTMIC/TCGA_LUAD_deconv.rds")
TCGA_LUAD_deconv <- readRDS("~/Datas/projects/data/import_data/RiTMIC/TCGA_LUAD_deconv.rds")

# Extraction des matrices T et A
T_est = as.matrix(TCGA_LUAD_deconv$methylation)
A_est = as.matrix(TCGA_LUAD_deconv$proportions)

T_final_EDec <- EDec::run_edec_stage_2(TCGA_LUAD_trs$data, A_est)
deconv_matrices <- list(Aest = A_est, Test = T_final_EDec$means)
saveRDS(deconv_matrices,"~/Datas/projects/data/import_data/RiTMIC/TCGA_Luad_estimated_matrix_deconv.rds")


while (!is.null(dev.list()))  dev.off()
pdf("heatmap_T_EDec2.pdf")
pheatmap(T_final_EDec$means)
dev.off()

library(ComplexHeatmap)
while (!is.null(dev.list()))  dev.off()
pdf("density_heatmap_T_EDec2.pdf")
ComplexHeatmap::densityHeatmap(T_final_EDec$means)
dev.off()

publi_Jun <- c("TP53","KRAS","KEAP1","STK11","EGFR","ALK","ROS1","PD-1","PD1","PDL1","PD-L1","ERBB2","HER2","DCD1","AFF2","PRC1","SYDE1","TRIM33","ZBTB7B","AGER", "SFTPA2", "CACNA2D2", "LAMP3", "SCGB1A1", "SFTPB", "SFTPC","CAV2","MUC1")
publi_Jun %in% rownames(T_final_EDec$means)
gene_present <- publi_Jun %in% rownames(T_final_EDec$means)
publi_Jun[gene_present]
biblio_Jun <- c()
biblio_Jun$mean <- T_final_EDec$means[publi_Jun[gene_present],]
biblio_Jun$sd <- T_final_EDec$std.errors[publi_Jun[gene_present],]

library(pheatmap)
while (!is.null(dev.list()))  dev.off()
pdf("heatmap_jun.pdf")
pheatmap(biblio_Jun$mean)
dev.off()

```
# Enrichissement Yuna
```{r, label = "Data Loading"}
path  = "~/Datas/projects/data/import_data/RiTMIC/"
A_T_matrices <- readRDS(paste0(path, "TCGA_Luad_estimated_matrix_deconv.rds"))
Aest <- A_T_matrices$Aest
Test <- A_T_matrices$Test

dbmarkers = readRDS(paste0(path, "CellMatchCurated.RDS"))
dbmarkers <- subset(dbmarkers, dbmarkers$tissueType=="Lung")
cancertypes = levels(as.factor(dbmarkers$cancerType))

```

## Loading Yuna's functions 
```{r, label= "Yuna's functions"}
#Fonctions for unsupervised enrichment
enrichplot = function(mydata, markerscelltypes, showCategory){
  enrich = function(x, markerscelltypes, showCategory, plot_title){
    genes=sort(x,decreasing=TRUE)
    #set.seed(1)
    # fgsea needs to have markercelltypes: $pathway -> gene1, gene2, gene 3....
    #and numeric genes expressions 
    fgseaRes = fgseaMultilevel(markerscelltypes, genes, minSize=2, maxSize=200)
    fgseaResDF = data.frame(fgseaRes)
    # Apply a score
    fgseaResDFSIGN = fgseaResDF[which(fgseaResDF[,"pval"]<0.05 & fgseaResDF[,"ES"]>0),c("pathway", "pval", "ES")]
    # Ranking 
    fgseaResDFSIGN = fgseaResDFSIGN[order(fgseaResDFSIGN[,"pval"], decreasing = FALSE),]
    if(nrow(fgseaResDFSIGN)==0){
      p = print("No significant cell-type enrichment")
    } else {
      fgseaResDFSIGN = fgseaResDFSIGN[1:min(showCategory, nrow(x)),]
      # Extract lines if the first column (Pathway) is not NA
      fgseaResDFSIGN = fgseaResDFSIGN[!is.na(fgseaResDFSIGN[,1]),]
      # Transform pval in -log10(pval)
      fgseaResDFSIGN[,"-log10(pval)"] = -log10(fgseaResDFSIGN[,"pval"])
      # Reranking
      fgseaResDFSIGN = fgseaResDFSIGN[order(fgseaResDFSIGN[,"pval"], decreasing = TRUE),]
      fgseaResDFSIGN$pathway <- factor(fgseaResDFSIGN$pathway, levels=fgseaResDFSIGN$pathway)
      p <- ggplot(fgseaResDFSIGN, aes(x=pathway, y=-log10(pval), fill =ES))+
        geom_bar(stat='identity') + scale_fill_continuous(low="white", high="red")+coord_flip()+ggtitle(plot_title)
    }
    return(p)
  }
  
  allplots = list()
  for (col in 1:ncol(mydata)){
     plot_title = paste("Estimated component", col, sep = " ")
        print(plot_title)
    allplots[[col]] = enrich(mydata[,col], markerscelltypes, showCategory, plot_title =  plot_title)
  }
  return(allplots)
  #return(apply(mydata, 2,  enrich, markerscelltypes, showCategory))
  #subplot(allplots, nrows = length(allplots), margin = 0.07)#, margin = c(0,0,0.07,0.07))
  #cowplot::plot_grid(plotlist = allplots, nrow = ncol(mydata), labels = colnames(mydata))
}

# Apply on every matrix column a boolean test to test the maximum values 
# Then apply a sign inversion to the matrix if the test is true
orient_funct <- function(S) {
  orient <-
    apply(S, 2, function(x) {
      if (min(x) < -3 & max(x) > 3) {
        ifelse (sum(x > 3)  < sum(x < -3), -1, 1)
      } else {
        ifelse (sum(x > 2)  < sum(x < -2), -1, 1)
      }
    })
  S <- as.matrix(S)  %*% diag(orient)
  return(S)
}

#Functions for identifying Unsupervised number of components 
plot_k = function(D){
  svd. = svd(t(D))$d[1:min(30, ncol(D))]
  ggplot(data.frame(val = svd., idx = 1:min(30, ncol(D))), aes(x = idx, y = val)) +s
    geom_line() + geom_point() + scale_x_continuous(breaks = 1:min(30, ncol(D)))+
    labs(x = "PC index", y = "Eigenvalues") +
    theme_minimal(base_size = 16)
}

#Function that generate the plot
plot_enrichment= function(dat, dbmarkers, input)  {  
        
        if(input$radio012 == "ICA-based"){
          datemp = orient_funct(dat)
          colnames(datemp) =  colnames(dat)
          dat = datemp
        }
        if(input$select1 == "ALL"){
          markerscelltypes = tapply(dbmarkers$geneSymbol,dbmarkers$cellIDcancer, cbind)
        } else {
          dbmarkers. = dbmarkers[dbmarkers$cancerType == input$select1,]
          markerscelltypes = tapply(dbmarkers.$geneSymbol,dbmarkers.$cellID, cbind)
        }
        
return(enrichplot(dat, markerscelltypes, showCategory = 10))

}

show_markers = function(dat, dbmarkers, input)  {  
  if(input$radio012 == "ICA-based"){
          datemp = orient_funct(dat)
          colnames(datemp) =  colnames(dat)
          dat = datemp
        }
  return(apply(dat, 2, function(x){rownames(dat)[order(x, decreasing = TRUE)[1:100]]}))
}

plot_cell_prop = function (dat, sample_id, celltype_id){
cell_prop_plot = list()

hm = pheatmap(dat, clustering_method = "ward.D2", silent = TRUE)
tmp_dat = dat[hm$tree_row$order, hm$tree_col$order]
        
cell_prop_plot$p1 = plot_ly(x = colnames(tmp_dat), y = rownames(tmp_dat), z = round(dat, 4), type = "heatmap", height = 1000) %>% layout(margin = c(0,0,50,50), title = "Heatmap - Cell vs Samples")
        
hm = pheatmap(dat, clustering_method = "ward.D2", silent = TRUE)
tmp_dat = dat[hm$tree_row$order, hm$tree_col$order]
        
cell_prop_plot$p2 = plot_ly(x = rownames(tmp_dat), y = tmp_dat[,sample_id], type="bar", name = "Cells", height = 1000) %>% layout(title = "Cell types distribution in the first sample selected sample", yaxis = list(hoverformat = ".2f"), margin = c(0,0,50,50))

hm = pheatmap(dat, clustering_method = "ward.D2", silent = TRUE)
tmp_dat = dat[hm$tree_row$order, hm$tree_col$order]

cell_prop_plot$p3 = plot_ly(x = colnames(tmp_dat), y = as.numeric(tmp_dat[celltype_id,]), type="bar", name = "Samples", height = 1000) %>% layout(title = "Selected celltype number 1 proportion across samples", yaxis = list(hoverformat = ".2f"), margin = c(0,0,50,50))
return (cell_prop_plot)

}
```

```{r, label= "Enrichment"}
dat = as.matrix(Test)
dim(dat)
input = list()
input$radio012 = "NMF-based" #is it an ICA based method?
input$select1 = "ALL" #is it an all cell type query

dat = as.matrix(Test)
dbmarkers <- subset(dbmarkers, dbmarkers$tissueType=="Lung")
allplots = plot_enrichment(dat, dbmarkers, input)
allplots
show_markers  (dat, dbmarkers, input)

```
